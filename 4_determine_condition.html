<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>4 Determine Conditions</title>
  <script src = "./extra_functions/jquery-3.4.1.js" type="text/javascript"></script>
  <script src="./extra_functions/helper_functions.js"> </script>
  <script src='./extra_functions/lodash.js'></script>
  <script src="jatos.js"></script>
  </head>
<body></body>
<script>

  jatos.onLoad(function() {

    // debugger

    // Counter for advancing through sessions
    jatos.studySessionData.session_counter = {
      phase_1: 1,
      phase_2: 1
    }
    jatos.studySessionData.phase_counter = 1;    
    
    jatos.studySessionData.progress_state = 'starting' // a string that will say whether to advance a session, phase, fail the participant, or whatnot.

    // Which scripts have which component IDs?
    jatos.studySessionData.script_comp_pos = {
      instructions:               5,
      practice_trials:            6,
      post_practice_instructions: 7,
      intermediate_feedback:      9,   
      qc_checks:                  10,
      data_submission:            12,
      break:                      13,
      phase_pa:                   8
    }

    // A conditional that determines whether we are debugging or not. If debugging, fewer trials will be done.
    // The pilot flag is for when asking labmates to test the paradigm, it just reduces the number of trials they'll have to do per sesiosn.
    // Auto respond: script will make random responses by itself.
    jatos.studySessionData.debug                    = 1;
    jatos.studySessionData.debug_n_trials           = 5;
    jatos.studySessionData.show_correct             = 0;
    jatos.studySessionData.pilot                    = 0;
    jatos.studySessionData.pilot_n_trials           = 10;
    jatos.studySessionData.auto_respond             = false;
    jatos.studySessionData.auto_respond_trial_dur   = 100; // milliseconds
    jatos.studySessionData.perf_check_over_n_trials = 15; // Over how many previous trials is the performance calculated?

    // Duration of trials, breaks, ITI, etc
    if (jatos.studySessionData.debug == 1 || jatos.studySessionData.pilot == 1) {
      jatos.studySessionData.short_break_duration = 2; // seconds
      jatos.studySessionData.long_break_duration  = 2; // seconds

      jatos.studySessionData.timer_after_response    = 100; // milliseconds
      jatos.studySessionData.timer_no_resp_fb_freeze = 500; // milliseconds
      jatos.studySessionData.timer_response_window   = 7000; // milliseconds            
      jatos.studySessionData.post_trial_gap          = 100; // milliseconds
      jatos.studySessionData.n_practice_trials       = 2;

      // Minimum % correct on each item
      jatos.studySessionData.training_criterion = 0;

    } else {

      jatos.studySessionData.short_break_duration = 15; // seconds
      jatos.studySessionData.long_break_duration  = 30; // seconds

      jatos.studySessionData.timer_after_response    = 500; // milliseconds
      jatos.studySessionData.timer_no_resp_fb_freeze = 3000; // milliseconds
      jatos.studySessionData.timer_response_window   = 10000; // milliseconds                  
      jatos.studySessionData.post_trial_gap          = 500; // milliseconds
      jatos.studySessionData.n_practice_trials       = 6;
      
      jatos.studySessionData.training_criterion = 80;

    };

    // Add all the QC checking conditions
    if (jatos.studySessionData.pilot || jatos.studySessionData.debug){
      jatos.studySessionData.qc_criteria = {
        rt_min_speed:        10,
        rt_min_perc:         100,
        uniform_resp_perc:   100,
        min_perf_check_perc: 50,
        perc_max_missed:     100,
        max_training_sess:   10,
      }
    } else {
      jatos.studySessionData.qc_criteria = {
        rt_min_speed:        1000,
        rt_min_perc:         80,
        uniform_resp_perc:   100,
        min_perf_check_perc: 50,
        perc_max_missed:     40,
        max_training_sess:   10,               
      }
    }

    // Create an object with pass-fail info for each criteria
    jatos.studySessionData.qc_status = {
      global_pass:            true,
      rt_pass:                true,
      uniform_resp_perc_pass: true,
      min_perf_pass:          true,
      practice_pass:          true,
      perc_max_misses_pass:   true,
      max_training_sess_pass: true,
    }


    // ////////////////////////////////////////////////////////////////////////////////////////
    // ////////////////////////////////////////////////////////////////////////////////////////  

    // Now, allocate coordinates for all empty location
    const targetCoordsNames = {
        pointNamesEmpty: ['E1','E2','E3','E4','E5','E6','E7','E8','E9','E10','E11','E12','E13','E14','E15','E16'],
        pointNamesTarget: ['T1','T2','T3','T4','T5','T6'],

        imgNamesEmpty: Array(16).fill('Empty'),
        imgNamesTarget: {
          phase_1: ['Tree','Santa','Bell','Sledge','Gingerman','Bear'], 
          phase_2: ['Tree','Santa','Bell','Sledge','Gingerman','Bear'],
        },
        pointXCoord: [],
        pointYCoord: [],
    }

    for (iX = 0; iX < 4; iX++){
        for (iY = 0; iY < 4; iY++){
            targetCoordsNames.pointXCoord.push(iX * 50 + 100);
            targetCoordsNames.pointYCoord.push(iY * 50 + 100);                
        }
    }

    // Randomly choose the target indices
    // let chosenTarget_idxs = _.sampleSize(targetCoordsNames.pointNamesTarget.length, basic_parameters.nTargets)
    let chosenTarget_idxs = {
      phase_1: [0,1,2], 
      phase_2: [0,1,2],
    }
    let chosenTargetLocations_phase_1 = [1,7,14] // These are base 1, so corresponding to the 16 points in the 4x4 space
    let congruent = true
    
    if (congruent){
      chosenTargetLocations_phase_2 = chosenTargetLocations_phase_1
    } else {

      // Choose it randomly


    }

    const basic_parameters = {

        // Display
        sort_area_width:      750,
        sort_area_height:     700,
        prompt_target_width:  70,
        prompt_target_height: 70,
        get prompt_img_x_coords() {
            return this.sort_area_width/2 - this.prompt_target_width/2;
        },
        prompt_img_y_coords: 80,            

        // Feedback items
        fb_correct_img:   './img/feedback/green_tick.png',
        fb_incorrect_img: './img/feedback/Red_x.png',
        audio_stimulus:   './img/feedback/success.wav',

        // Peformance box
        score_box_target_width:          30,
        score_box_target_height:         30,
        score_box_score_font_size:       13, // Size of the score text, "100%"
        score_box_description_font_size: 15, // "Your scores"

        ///////////////////////////////////////// Targets ////////////////////////////////////
        nTargets: 3,

        targetPoints: {
          phase_1: chosenTargetLocations_phase_1,
          phase_2: chosenTargetLocations_phase_2,
        },                
        
        // Point names, i.e. T1 T2 T6 etc
        targetPointNames: {
          phase_1: index_into_array(targetCoordsNames.pointNamesTarget,chosenTarget_idxs.phase_1),
          phase_2: index_into_array(targetCoordsNames.pointNamesTarget,chosenTarget_idxs.phase_2),
        },

        // Which target images are used for each phase?
        targetNamesUsed: {
          phase_1: index_into_array(targetCoordsNames.imgNamesTarget.phase_1,chosenTarget_idxs.phase_1),
          phase_2: index_into_array(targetCoordsNames.imgNamesTarget.phase_2,chosenTarget_idxs.phase_2),
        },        

        // Paths to the target images
        targetPathsUsed: {
          phase_1: [],
          phase_2: [],
        },

        // For all 16 points, what are the corresponding point names? For now, all E points
        pointNamesUsed: {
          phase_1: ['E1','E2','E3','E4','E5','E6','E7','E8','E9','E10','E11','E12','E13','E14','E15','E16'],
          phase_2: ['E1','E2','E3','E4','E5','E6','E7','E8','E9','E10','E11','E12','E13','E14','E15','E16']
        },

        // For all 16 points, what are the names for corresponding image? For now, all "Empty" items
        imgNamesUsed: {
          phase_1: Array(16).fill('Empty'),
          phase_2: Array(16).fill('Empty')
        },
    }

    // Variable to hold the running performance for each phase
    let running_perf = {
      phase_1: new Array(basic_parameters.nTargets).fill(0),
      phase_2: new Array(basic_parameters.nTargets).fill(0),
    }

    // For each phase, specify which points are used as targets, paths to those targets, and the names of all 16 points.
    for (iPhase=1; iPhase<3; iPhase++){
      let phase_string = 'phase_'+iPhase

      for (iT=0; iT<basic_parameters.nTargets; iT++){

        // Which of the 16 locations are we changeing?
        let iLocation  = basic_parameters.targetPoints[phase_string][iT]-1
        // Whats the name of the target point? (T1, T5, etc)
        let iPointName = targetCoordsNames.pointNamesTarget[chosenTarget_idxs[phase_string][iT]]        
        // Whats the name of the target? (Bell, Tree, etc)a
        let iImageName =  targetCoordsNames.imgNamesTarget[phase_string][chosenTarget_idxs[phase_string][iT]]

        // Change the E1 E2 E3 etc. Intersperce it with Target point names
        basic_parameters.pointNamesUsed[phase_string][iLocation] = iPointName
        basic_parameters.imgNamesUsed[phase_string][iLocation]   = iImageName
             
        // For the score box, create names of the target itesm
        basic_parameters.targetPathsUsed[phase_string][iT] = './img/targets/' + iImageName + '.png'
      }
    }

    // Create an array of objects to hold which point goes as 1st and 2nd stimuli on the screen
    let baseTrialArray = {
      phase_1: genBaseTrialArray(cleanEmptyCombos(getCombos(basic_parameters.pointNamesUsed['phase_1']))),
      phase_2: genBaseTrialArray(cleanEmptyCombos(getCombos(basic_parameters.pointNamesUsed['phase_2']))),
    }

    // If debug, then shorten these arrays
    if (jatos.studySessionData.debug == 1){
      baseTrialArray.phase_1 = deepCopy(shuffle(baseTrialArray.phase_1).slice(0,jatos.studySessionData.debug_n_trials))
      baseTrialArray.phase_2 = deepCopy(shuffle(baseTrialArray.phase_2).slice(0,jatos.studySessionData.debug_n_trials))      
    }
    
    // Define the neck_legs_space
    let neck_legs_space = new ConceptCreator('neck_legs_space','birds',
        'neck','legs',
        undefined,350,10,10,
        [170,525],[350,400], // onscreen idx coords
        [90,560],[350,400]) // fb_imgs coords

    // Define the beak_tail_space            
    let beak_tail_space = new ConceptCreator('beak_tail_space','birds',
        'beak','tail',
        undefined,650,10,10,
        [220,310],[220,400], // onscreen idx coords
        [90,180],[250,450]) // fb_imgs coords                  

    let concepts = {
        phase_1: neck_legs_space,
        phase_2: beak_tail_space,
    }
    
    // Create an array that will hold paths to images to prelod. Will be filled in prior to each session
    let imgs_to_preload = {
      base_images:     [],
      exemplar_images: [],
    }

    imgs_to_preload.base_images = [basic_parameters.fb_correct_img, basic_parameters.fb_incorrect_img]

    // Record all these variables in JATOS
    jatos.studySessionData.inputData = {
      targetCoordsNames: targetCoordsNames,
      basic_parameters:  basic_parameters,
      baseTrialArray:    baseTrialArray,
      concepts:          concepts,
      imgs_to_preload:   imgs_to_preload,
      choices:           ['1','2'],
      nTrials:           baseTrialArray.phase_1.length,
      running_perf:      running_perf,
    }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
 
      jatos.studySessionData.debrief_questions = [

        {prompt: 'How did you try to remember which bird was associated with which toy? Did you have any strategy?', rows: 2, columns: 100}, 
        {prompt: 'Apart from trying to remember the associations in your memory,' +
                 'did you use any other tool to help you respond correctly? ' + 
                 'For example, taking a photo of the correct associations, or drawing the correct associations on a piece of paper? ' + 
                 'Note, you will not be penalised if you did do so. You will still receive your payment, ' + 
                 'but we will need to exclude your data from our analysis, so it is really important that we know this. ' +
                 'Thank you!', rows: 2, columns: 100},         
        {prompt: 'Did you notice the birds differed by their length of neck?', rows: 2, columns: 100},
        {prompt: 'Did you notice the birds differed by their length of legs?', rows: 2, columns: 100},
        {prompt: 'Did you notice any other way in which the birds differed from each other?', rows: 2, columns: 100},
        {prompt: 'Was anything unclear in the instructions for the task?', rows: 2, columns: 100},        
        {prompt: 'Is there anything that would make the experiment more fun or easier to perform?', rows: 2, columns: 100},                
      ]

    // ////////////////////////////////////////////////////////////////////////////////////////////
    // ////////////////////////////////////////////////////////////////////////////////////////////
    // Create save the sessions in jatos studySessionData.

    jatos.submitResultData("[conditions_start---" + 
    JSON.stringify(jatos.studySessionData) + "---conditions_end]", jatos.startNextComponent);

  });

  ////////////////////////////////////////////////////////////////////////////////////////////
  //                            All the subfunctions
  ////////////////////////////////////////////////////////////////////////////////////////////

  // Create a constructor function for creating an object with info for each space
  let ConceptCreator = function(concept_space,concept_object,dim1_name,dim2_name,
      ex_pairs_img_height,ex_pairs_img_width,ex_pairs_x_coord,ex_pairs_y_coord,
      onscreen_idx_x_coords,onscreen_idx_y_coords,
      fb_imgs_x_coords,fb_imgs_y_coords){

          this.concept_space          = concept_space,
          this.concept_object         = concept_object,
          this.dim1_name              = dim1_name,
          this.dim2_name              = dim2_name,
          this.ex_pairs_img_height    = ex_pairs_img_height,
          this.ex_pairs_img_width     = ex_pairs_img_width,
          this.ex_pairs_x_coord       = ex_pairs_x_coord,
          this.ex_pairs_y_coord       = ex_pairs_y_coord,
          this.onscreen_idx_x_coords  = onscreen_idx_x_coords,
          this.onscreen_idx_y_coords  = onscreen_idx_y_coords,   
          this.fb_imgs_x_coords       = fb_imgs_x_coords,
          this.fb_imgs_y_coords       = fb_imgs_y_coords
  }

  let getCombos = function(array){

    // A function to get an array with combinations of 2 items.
    // Basically, n choose k amount of elements.
    var result = array.flatMap(
        (v, i) => array.slice(i+1).map( w => [v,w] )
    );

    return result
  };

  let cleanEmptyCombos = function(array){
    // Function to delete the array items that contain both empty points
    let cleanedArray = []

    for (i=0; i<array.length; i++){
      if (array[i][0].includes('T') || array[i][1].includes('T')){
        cleanedArray.push(array[i])
      }
    }
    
    return cleanedArray
  };

  let genBaseTrialArray = function(combos){

    // Function to create the baseTrialArray object, containing item1 and item2 keys
    // specifying which of the points are 1st and 2nd items on the screen

    let baseTrialArray = []

    for (i=0; i<combos.length; i++){
      baseTrialArray[i] = {
        item1: combos[i][0],
        item2: combos[i][1],
      }
    }

    return baseTrialArray;
  };

</script>